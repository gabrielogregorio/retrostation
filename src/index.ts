import { app, BrowserWindow, ipcMain, shell } from 'electron';
import { exec } from 'child_process';
import { Worker } from 'worker_threads';
import path from 'path';
import { createConfig } from '@/config/createConfigFolders';
import { EVENT_NAMES } from '@/config/eventNames';
import { dispatchGameDataUpdated } from '@/events/dispatchGameDataUpdated';
import { GamesType, GlobalDataType } from '@/types/all';
import { getOsVersion } from '@/backend/getVBersion';
import { readUserData, saveUserData } from '@/loaders/user';
import { readDescriptionsData } from '@/loaders/descriptions';
import { readGamesData } from '@/loaders/games';
import { readPlatformsData } from '@/loaders/platforms';
import { readRunnersByFoldersData } from '@/loaders/runnerByFolder';
import { startStaticFilesServer } from '@/backend/server';
import { DEFAULT_API_PORT } from '@/config/index';
import { getLocalRunNode } from '@/backend/utils';

console.log('STARTING RETROSTATION');

// #####################################################
// # =================== DEFAULT SETUP =============== #
// #####################################################

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
// eslint-disable-next-line global-require
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Para deixar fontes bonitas
app.commandLine.appendSwitch('enable-font-antialiasing');
app.commandLine.appendSwitch('force-device-scale-factor', '1');

createConfig();
// #####################################################
// # =================== CUSTOM SETUP =============== #
// #####################################################

const createWindow = (): void => {
  const mainWindow = new BrowserWindow({
    title: 'Retrostation',
    height: 768,
    width: 1366,
    minHeight: 300,
    minWidth: 300,
    fullscreen: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false,
    },
  });

  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    // eslint-disable-next-line no-param-reassign
    delete details.responseHeaders['Content-Security-Policy'];
    callback({ responseHeaders: details.responseHeaders });
  });

  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
};

// #####################################################
// # ================== CUSTOM EVENTS =============== #
// #####################################################

ipcMain.handle('openFolder', async (_event, relativePathToOpen) => {
  await shell.openPath(path.resolve('./', relativePathToOpen));
});

ipcMain.handle('openWithFileSelected', async (_event, relativePathToOpen) => {
  await shell.showItemInFolder(path.resolve('./', relativePathToOpen));
});



ipcMain.on(EVENT_NAMES.runCliCommands, (event, payload) => {
  console.log(`CLI: ${payload.command}`);

  event.reply(EVENT_NAMES.runnerWasStarted, { path: payload.path });

  const absoluteCommand = path.resolve(getLocalRunNode(), payload.command);
  console.log(`CLI: PATH RESOLVED: ${absoluteCommand}`);

  const processCliCommand = exec(absoluteCommand, (error: Error | null, stdout: string, stderr: string) => {
    if (error) {
      console.error('❌ ### ERROR ####❌');
      console.error(error);
      console.error('❌ ### ERROR ####❌');
      event.reply(EVENT_NAMES.commandOutputResponse, `Erro: ${stderr}`);
      return;
    }

    event.reply(EVENT_NAMES.commandOutputResponse, `Saída: ${stdout}`);
  });

  processCliCommand.on('close', () => {
    event.reply(EVENT_NAMES.runnerHasStopped, { path: payload.path });
  });
});

/**
 * The use of child is due to the fact that the UI freezes if done otherwise. Using workers I can't
 * get it to work satisfactorily with typed text, so I opted for this alternative.
 */
ipcMain.on(EVENT_NAMES.runScrapper, (event) => {
  console.log('SCRAPPER: START');

  const pathWorkerScrapper = path.resolve(getLocalRunNode(), './static/workers/backend/scrapper.js');

  console.log('SCRAPPER: PATH WORKER', pathWorkerScrapper);
  const wc = event.sender;
  const worker = new Worker(pathWorkerScrapper);

  worker.on('message', (msg: { type: string; games: GamesType[] }) => {
    if (msg.type === 'done') {
      console.log(`SCRAPPER: DONE, games = ${msg.games.length}`);
      dispatchGameDataUpdated(msg.games);
      console.log('SCRAPPER: FINISHED DISPATCH');

      wc.send(EVENT_NAMES.outputRunScrapper, { success: true });
      console.log('SCRAPPER: REPLY');
    } else if (msg.type === 'error') {
      console.log('SCRAPPER: ERROR RUN');

      wc.send(EVENT_NAMES.outputRunScrapper, { success: false, error: 'Error on run scrapper' });
    }

    console.log('result message msg?.games?.length =', `${msg?.games?.length} type ${msg?.type}`);
  });

  worker.on('error', (err) => {
    console.log('SCRAPPER: ERROR WORKER');
    event.reply(EVENT_NAMES.outputRunScrapper, { success: false, error: err.message });
  });

  worker.on('exit', (code) => {
    console.log('SCRAPPER: WORKER EXITED WITH', code);
    if (code !== 0) {
      event.reply(EVENT_NAMES.outputRunScrapper, { success: false, error: `Worker exited with code ${code}` });
    }
  });
});

ipcMain.handle(EVENT_NAMES.getPlatformInfo, () => getOsVersion());

ipcMain.handle(EVENT_NAMES.getUserData, () => readUserData());

ipcMain.handle(EVENT_NAMES.getGlobalData, () => {
  const data: GlobalDataType = {
    descriptions: readDescriptionsData(),
    games: readGamesData(),
    platforms: readPlatformsData(),
    runnersByFolder: readRunnersByFoldersData(),
  };

  return data;
});

ipcMain.on(EVENT_NAMES.updateUserData, (_event, updatedData) => {
  console.log('saveUserData: RUN');
  saveUserData(updatedData);
  console.log('saveUserData: DONE');
});

app.commandLine.appendSwitch('lang', 'pt-BR');
if (process.type !== 'renderer' && !process.env.IS_CHILD_PROCESS) {
  app.on('ready', () => {
    startStaticFilesServer({ port: DEFAULT_API_PORT, serverIsStarted: () => createWindow() });
  });
}

// #####################################################
// # ================== DEFAULT EVENTS =============== #
// #####################################################

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
  console.log('window-all-closed: QUIT');
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
